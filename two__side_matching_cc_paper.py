# -*- coding: utf-8 -*-
"""two _side_matching_cc_paper.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11rlk3GI2HVVNwgNEkpIlHZS1n80xe8Ns
"""

M = 3 # Number of APs

Fk_values = [400, 500]  
Ck_values = [500, 1500]
Rk_values = [50, 80]
Fk_m_values = [3, 15]
Fm_values = [50, 100]
Rukm_values = [0.7, 1.2]
Rdkm_values = [2, 5]
akm = 0.2

import numpy as np
import random
fk=[] #The local CPU frequency,
ck=[] #Data size of each user,
rk=[] #BIts of each user,
fm = apCpuEachSlot = [] # Fm
network_vars=[]
def assign(k):
  
  for i in range(30):
      Fk = random.choice(Fk_values)
      fk.append(Fk)
      

      Ck = random.choice(Ck_values)
      ck.append(Ck)
      Rk = random.choice(Rk_values)
      rk.append(Rk)
      Fk_m = [random.choice(Fk_m_values) for j in range(M)] #Computational speed of the edge cloud assigned by AP m to user k,
      Rukm = [random.choice(Rukm_values) for j in range(M)] #Uplink transmission rates,
      Rdkm = [random.choice(Rdkm_values) for j in range(M)] #Downlink transmission rates,
      network_vars.append((Fk, Ck, Rk, Fk_m, Rukm, Rdkm))

assign(30)

lkm = [] #bitstooffload
def compute_bits_to_offload(k):
  
  for i in range(30):
      Fk, Ck, Rk, Fk_m, Rukm, Rdkm = network_vars[i]
      L_values = []
      for j in range(M):
          L = (akm * Ck) / (Rukm[j] * Fk_m[j]) + ((1 - akm) * Ck) / (Rdkm[j] * Fk_m[j])
          L_values.append(L)
      min_L = min(L_values)
      bits = (min_L * Fk * Rk) / (Ck * sum(Fk_m))
      lkm.append(bits)

compute_bits_to_offload(30)

#Function to create user prefarence Profile 
#Finds the AP prefarence value of each user and sorts them in increasing order

user_profile = [[]*30]
def preference_user(k):
  for i in range(k):
    for j in range(3):
      user_profile[i].append([lkm[i][j], j])
  
  for i in range(k):
    user_profile.sort()

#Function to create AP prefarence Profile 
#Finds the user prefarence value of each AP and sorts them in decreasing order

ap_profile = [[]*3]
def preference_ap(k):
  for i in range(3):
    for j in range(k):
      ap_profile[i].append([lkm[j][i] * ck[j], j])
  
  for i in range(3):
    ap_profile.sort(reverse = True)

# Algorithm that computes all operations locally
# Used as a comparision

def local_compute(k):
  time = 0
  for i in range(0,k):
    time += rk[i] * ck[i] / fk[i]
  avg_latency = time/k
  return avg_latency

#Algorithm for A Two-Sided Matching Approach for Distributed Edge Computation Offloading
# Returns the user - AP mapping for offfloading

def two_sided_matching(pk,pm,k):
  match = [[False for _ in range(3)] for _ in range(30)]
  for i in range(k):
    user = i
    for _, ap in pk[i]:
      offload = lkm[user][ap]
      computationCapacity = offload*ck[user]
      if fm[ap] >= computationCapacity:
        fm[ap] -= computationCapacity
        match[user][ap] = True
      else:
        order = dict()
        for o in range(k):
          order[ap_profile[ap][1]] = 0
        order = sorted(order, key=lambda x : (x[1], x[0]))
        order = dict()
        for u,v in order:
          order[u] = v
        res = 0
        for i in range(k):
          if match[i][ap] and order[i] < order[user]:
            res += lkm[i][ap]
            match[i][ap] = False
        
        if fkm[ap] + res >= computationCapacity:
          match[user][ap] = True
    return match

def two_sidedmatching(k):
  ap_resources = [1 for i in range(M)] # initialize resources to 1 for each AP
  mapping = [-1 for i in range(k)] # initialize mapping to -1 for each user
  for i in range(k):
      Fk, Ck, Rk, Fk_m, Rukm, Rdkm = network_vars[i]
      user_prefs = [(j, Fk_m[j], Rukm[j], Rdkm[j]) for j in range(M)]
      user_prefs.sort(key=lambda x: x[1], reverse=True)
      for j in range(M):
          ap_idx = user_prefs[j][0]
          if ap_resources[ap_idx] > 0:
              mapping[i] = ap_idx
              ap_resources[ap_idx] -= 1
              break
  return mapping

def two_sided_latency(k):
  xkm = two_sidedmatching(k)
  
  total_latency = 0
  for i in range(k):
      Fk, Ck, Rk, Fk_m, Rukm, Rdkm = network_vars[i]
      ap_idx = xkm[i]
      L = (akm * Ck) / (Rukm[ap_idx] * Fk_m[ap_idx]) + ((1 - akm) * Ck) / (Rdkm[ap_idx] * Fk_m[ap_idx])
      latency = Ck * Rk / (Fk * sum(Fk_m) * lkm[i]) + L
      total_latency += latency
  average_latency = total_latency / 30
  return average_latency

import matplotlib.pyplot as plt

users = [10,15,20,25,30] #Number of Users,
local_latency = []
for i in users:
  local_latency.append(local_compute(i))

two_sided_lateny = []

for j in users:
  
  two_sided_lateny.append(two_sided_latency(j))

plt.plot(users,local_latency)
plt.plot(users,two_sided_lateny)

plt.xlabel('Number of Users')
plt.ylabel('Average latency(ms)')
plt.title('Influence of the number of users')
 
plt.show()

